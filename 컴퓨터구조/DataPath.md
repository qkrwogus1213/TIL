# 기본적인 MIPS 구현

**1.핵심적인 MIPS명령어 집합의 부분집합**

- 메모리 참조 명령어인 lw와 sw
- 산술/논리 명령어인 add,sub,AND,OR,slt
- 분기 명령어인 beq와 j

**2.이러한 명령어들을 구현의 필요한 처음 두 단계**

 	1. PC를 프로그램이 저장되어 있는 메모리에 보내어 메모리로 부터 명령어를 가져온다.
		2. 읽을 레지스터를 선택하는 명령어 필드를 사용하여 하나 또는 두 개의 레지스터를 읽는다. lw명령어는 레지스터 하나만 읽으면 되지만 대부분의 다른 명령어는 레지스터 두 개를 읽음

이 두 단계 이후 명령어 실행을 끝내기 위한 행동은 명령어 종류에 따라 달라지지만, (메모리 참조, 산술/논리, 분기)명령어는 대부분 같음.

**3.두 단계 이후 행동들**

1. 점프 명령어를 제외한 모든 명령어 종류가 레지스터를 읽은 후에 ALU 사용
2. 메모리 참조 명령어는 주소를 사용하기위해 분기명령어는 비교를 하기 위해 ALU를 사용
3.  ALU를 사용 후 명령어 실행을 끝내는데 필요한 행동들은 서로 다름
4. 메모리 참조 명령어는 메모리에 접근. 산술/논리 명령어와 적재 명령어는 ALU나 메모리에서 온 데이터를 레지스터에 써야함, 분기명령어는 비교 결과에 따라 다음 명령어의 주소를 바꾸거나 PC값을 4만큼 증가시켜 다음 명령어의 주소를 갖게 할 수 도 있음.

![1](C:\Users\parkjaehyun\Desktop\TIL\Images\1.PNG)



# DataPath

명령어를 저장하고 접근하는 데 두 개의 소자가 필요하며 다음 명령어의 주소를 계산하기 위해 덧셈기가 하나 필요하다.

어느 명령어든지 실행하기 위해서는 메모리에서 명령어를 가져오는 것으로 시작해야 한다. 모든 R형식 명령어들은 두 개의 레지스터를 읽고 레지스터 내용에 ALU연산을 수행하며 그 결과를 레지스터에 쓴다.  ALU는 32비트 입력 두개를 받아서 3비트 결과와 결과가 0인지 아닌지를 나타내는 1비트 신호를 만든다. 따라서 R형식 ALU연산을 구현하는 데 필요한 두 개의 구성 요소는 레지스터 파일과 ALU이다.

산술/논리(R형식)명령어 데이터패스와 메모리 명령어 데이터패스의 차이점

- 산술/논리 연산 명령어는 ALU를 사용하는데 입력은 두 레지스터에서 부터 온다. 메모리 명령어 역시 주소를 계산하기 위하여 ALU를 사용하지만 ALU의 두번째 입력은 명령어의 16비트 변위 필드를 부호확장한 값이다.
- 목적지 레지스터에 저장되는 값은 ALU에서(R 형식 명령어인 경우) 오거나 메모리에서(적재 명령어의 경우)온다.

## 주 제어 유닛의 설계

- opcode라 불리는 op필드는 항상 비트 31:26에 포함된다. 이필드를 Op[5:0]이라 부른다
- 읽을 레지스터 두 개는 항상 rs,rt 필드에 으해 지정되는데 rs, rt 필드는 비트 25:21과 비트 20:16에 나타난다. 이것은 R형식 명령어, 같을 시 분기 및 저장 명령어에 적용된다.
- 적재 명령어와 저장 명령어를 위한 베이스 레지스턴튼 항상 비트 25:21(rs)에 있다.

## DataPath의 동작

1. 명령어를 명령어 메모리에서 가져오고 PC값을 증가시킨다.
2. 두 레지스터 $t2 와 $t3를 레지스터 파일로부터 읽는다. 이 단계에서 주 제어 유닛이 제어선의 값들을 계산한다.
3. ALU는 레지스터 파일에서 읽어 들인 값들에 대해 연산을 하는데 기능 코드(명령어의 funct 필드인 비트 5:0)를 사용하여 ALU제어신호를 만든다.

## 적재 명령어의 동작

1. 명령어를 명령어 메모리에서 가져오고 PC값을 증가시킨다.
2. 레지스터($t2)값을 레지스터 파일로부터 읽는다
3. ALU는 레지스터 파일에서 읽어 들인 값가 명령어의 하위 16비트(offset)를 부호확장한 값과의 합을 구한다.
4. 이 합을 데이터 메모리 접근을 위한 주소로 사용한다.
5. 메모리 유닛에서 가져온 데이터를 레지스터 파일에 기록한다. 목적지 레지스터($t1)는 명령어의 비트 20:16이 지정한다.

## 분기 명령어의 동작

1. 명령어를 명령어 메모리에서 가져오고 PC값을 증가시킨다.
2. 두 레지스터 $t1과 $t2를 레지스터 파일로 부터 읽는다.
3. ALU는 레지스터 파일에서 읽어 들인 값들에 대해 뺄셈을 한다. 명령어의 하위 16비트를 부호확장한 후 2비트 왼쪽 자리이동한 값에다가 PC+4값을 더한다. 결과 값이 분기 목적지 주소이다
4. 어떤 덧셈기의 결과를 PC에 저장할지 ALU의 Zero출력을 이용하여 판단한다.