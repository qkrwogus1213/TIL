# DataHazrd

## 파이프라인 해저드

1. 구조적 해저드
   - 다른 단계에 있는 명령어들이 동시에 같은 자원을 사용하려고 하는 상황
   - 해결 방법: 해당 자원을 여러 개 설치
2. 데이터 해저드
   - 앞의 명령어의 결과를 사용해야 하는데, 앞의 명령어가 끝나지 않아 아직 결과를 사용할 수 없는 상황
   - 해결 방법: 파이프라인 지연, 전방전달(forwarding)등
3. 제어해저드
   - 앞의 분기 명령어가 분기할지 안할지 몰라서 다음 명령어를 인출할 수 없는 상황
   - 해결 방법: 파이프라인 지연, 분기 예측, 지연 분기

## MIPS 명령어 파이프라인의 5단계

1. IF (Instruction fetch): 명령어 인출 
2. ID (Instruction decode): 명령어 해독 및 레지스터 파일 읽기 
3. EX (Execution): 실행 및 주소 계산 
4. MEM (Memory): 데이터 메모리 접근 5. WB (Write back): 레지스터에 쓰기

## 단일 사이클 데이터패스의 분할

1. 왼쪽에서 오른쪽으로 가는 정보 흐름의 두가지 예외
   - WB 단계: 결과를 데이터패스의 중앙에 있는 레지스터 파일에 쓰기 => 데이터 해저드
   - PC의 다음 값 선정: 증가된 PC 값과 MEM단계의 분기 주소 중에서 선택 => 제어 해저드

## 파이프라인 제어신호

1. IF: 없음 (항상 같은 일이 일어난다)
2. ID: 없음 (항상 같은 일이 일어난다) 
3. EX: RegDst, ALUOp, ALUSrc
4. MEM: Branch(beq 명령), MemRead(lw 명령), MemWrite(sw 명령)
5. WB: MemtoReg, RegWrite

## 데이터 해저드 발생 조건

1. 데이터 종속성

   - 어떤 명령어가 아직 파이프라인에 있는 앞선 명령어의 결과를 사용해야 할 때 

     ex)	add $s0, $t0, $t1

     ​    	 sub $t2, $s0, $t3 

2. 종속적인 두 명령어가 충분히 가까울 때

   - 두 명령어 사이의 거리는 파이프라인 구조에 따라 달라진다. 

**해결 방법**

1. 파이프라인 지연
2. nop 삽입
3. 파이프라인 스케줄링
4. 전방전달 또는 우회
   - 데이터가 사용 가능하면 바로 필요로 하는 유닛에 전달 
   - 레지스터에 저장할 때까지 기다리지 않고, 
   - 파이프라인 레지스터에서 직접 값을 읽는다. 
   - 데이터패스에 멀티플렉서와 새로운 연결 추가

## 전방전달 멀티 플렉서의 제어신호

- ForwardA=00 ID/EX 
  - ALU의 첫번째 피연산자가 레지스터 파일에서 온다.
- ForwardA=10 EX/MEM
  -  ALU의 첫번째 피연산자로 직전 명령어의 ALU 결과가 전 방전달된다. (1a 해저드)
- ForwardA=01 MEM/WB
  -  ALU의 첫번째 피연산자로 데이터 메모리에서 읽은 값 또 는 전전 명령어의 ALU 결과가 전방전달된다. (2a 해저드)
-  ForwardB=00 ID/EX 
  - ALU의 두번째 피연산자가 레지스터 파일에서 온다. 
- ForwardB=10 EX/MEM 
  - ALU의 두번째 피연산자로 직전 명령어의 ALU 결과가 전 방전달된다. (1b 해저드) 
- ForwardB=01 MEM/WB
  -  ALU의 두번째 피연산자로 데이터 메모리에서 읽은 값 또 는 전전 명령어의 ALU 결과가 전방전달된다. (2b 해저드)

## 데이터 해저드와 지연

적재-사용 데이터 해저드 

- 적재 명령어가 메모리에서 읽어 온 데이터를 바로 뒤의 명령어가 사용하 려 할 때 생기는 해저드
-  전방전달을 해도 1 클럭 사이클의 지연이 필요하다.

## 지연 적재 delayLoad

- 컴파일러의 적재-사용 데이터 해저드 해결 방법
  -  적재 명령어 다음에는 이 적재와 무관한 명령어가 오게 한다.
  -  최악의 경우에는 nop 명령어 삽입

## 제어 헤저드

- 제어 해저드(control hazard) 또는 분기 해저드(branch hazard) 
  -  인출한 명령어가 필요한 명령어가 아니기 때문에 적절한 명령어가 적절 한 클럭 사이클에 실행될 수 없는 사건 
  -  명령어 주소의 흐름이 파이프라인이 기대한 것과 다르기 때문에 발생 
  - 매 클럭마다 명령어를 인출해야 하는데, 분기 명령어의 경우 인출할 다 음 명령어를 바로 알 수 없다.  
- 해결 방법 
  - 분기 시 지연
    - 분기 여부가 결정될 때까지 다음 명령어 인출을 연기
    -  분기 명령어가 나올 때마다 파이프라인 지연
    -  분기가 MEM 단계에서 실행될 때, 3 클럭 분기 손실
  - 분기 예측
    - 실제 분기 결과가 확인될 때까지 기다리는 대신, 분기 결과를 가정하고 그 가정 하에 파이프라인을 진행해 나가는 분기 해저드 해결 방법 
    -  분기 결과를 예측 :  예측이 맞으면 지연 없이 진행 
    - 예측 실패 손실:   예측이 틀렸을 때만 생기는 파이프라인 지연
  - 지연 분기
    - 지연 분기
      -  다음 순서의 명령어를 항상 실행하고, 실제 분기는 그 명령어를 파이프라 인에 넣고 나서 한 사이클 늦게 일어난다. 
    - 분기 지연 슬롯 
      -  지연 분기 명령어 바로 다음 슬롯 
      -  컴파일러와 어셈블러는 분기 여부와 상관 없이 항상 실행되는 명령어로 채운다. 
    -  지연 분기와 동적 분기 예측 
      - 매 사이클마다 명령어 하나씩 내보내는 5 단계 파이프라인의 경우에는 지 연분기가 간단하면서도 효과적 
      -  단계 수가 많아지고 동시에 여러 명령어를 내보내는 경우, 지연 슬롯 하나 로는 충분하지 않다.

## Exception과 Interrupt

- 분기 명령어나 점프 명령어가 아니면서 명령어 실행의 정상적인 흐름을 바꾸는 사건 
-  처음에는 프로세서 내부의 예상치 못했던 사건(예: 오버플로) 처리용 
-  Intel x86은 인터럽트라는 용어만 사용 

예외 원인의 판별

- Non-vectored 인터럽트 
  -  모든 인터럽트가 같은 인터럽트 핸들러 사용
  -  인터럽트 핸들러가 폴링으로 원인 파악
  -  해당 서비스 루틴으로 점프
- Vectored 인터럽트 
  -  예외 원인에 따라 점프 주소가 달라진다. 
  -  인터럽트 벡터
    -  인터럽트 요청 장치가 인터럽트 벡터를 CPU에 제공 
    -  CPU는 이를 이용하여 인터럽트 서비스 루틴의 주소 생성
    - 보통 인터럽트 벡터 테이블의 인덱스로 사용



